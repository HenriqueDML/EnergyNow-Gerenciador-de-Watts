
# --------- 1TDSPK -------------
# RM - 557197 = Larissa Muniz
# RM - 558843 = Laura Cintra
# RM - 558062 = Henrique Garcia

# IMPORTAÇÕES
from datetime import datetime, date

import os
import oracledb
import requests

import json

"""Link do site da api: https://app.ipgeolocation.io/dashboard"""


"""Função: utiliza uma API de geolocalização para obter a localização atual baseada no endereço do IP do usuário
- faz uma requisição HTTP para a API, 
- processa a resposta e retorna a cidade, estado e páis em formato de string
- se houver erro, um mensagem apropriada será retornada

- Retornos:
- str: uma string com a localização no formato "cidade, estado, país" se a requisiçãõ for bem-sucedida
- str: "Localização não encontrada" se a resposta da API não for bem-sucedida
- str: uma mensagem de erro no formato "Erro ao obter localização: {mensagem de erro}" em caso de exceção
"""
def get_location():
    api_key = 'a845a9b6876e4472ae7ac96629b97ba4'  
    try:
        response = requests.get(f'https://api.ipgeolocation.io/ipgeo?apiKey={api_key}')
        if response.status_code == 200:
            data = response.json()
            return f"{data['city']}, {data['state_prov']}, {data['country_name']}"
        else:
            return "Localização não encontrada"
    except Exception as e:
        return f"Erro ao obter localização: {e}"

# CONEXÃO COM O BANCO DE DADOS
try:
    conn = oracledb.connect(user="RM557197", password="281205", dsn='oracle.fiap.com.br:1521/ORCL')
 
    inst_cadastro = conn.cursor()
    inst_consulta = conn.cursor()
    inst_alteracao = conn.cursor()
    inst_exclusao = conn.cursor()
    inst_filtro = conn.cursor()

except Exception as e:
    print("Erro: ", e)
    conexao = False
else:
    conexao = True


""" INSTRUÇÕES SLQ 
DROP TABLE historico_servicos CASCADE CONSTRAINTS;
DROP TABLE veiculos CASCADE CONSTRAINTS;
DROP TABLE diagnosticos CASCADE CONSTRAINTS;
DROP TABLE orcamentos CASCADE CONSTRAINTS;

SELECT * FROM veiculos;
SELECT * FROM diagnosticos;
SELECT * FROM historico_servicos;
SELECT * FROM orcamentos;
"""


"""Procedimento: cria as tabelas veiculos, diagnostico, historico_servicos e orcamentos no banco de dados
- Cada tabela é definida com seus campos e restrições, incluindo haver primárias e estrangeiras
- Lida com exceções de banco de dados e exibe mensagens apropriadas em caso de erro.

"""
def criar_tabelas():
    try:
        # Criar tabela de veículos
        inst_cadastro.execute(''' 
            CREATE TABLE veiculos (
                placa VARCHAR2(8) PRIMARY KEY NOT NULL,
                modelo VARCHAR2(100) NOT NULL,
                localizacao VARCHAR2(255) NOT NULL
            )
        ''')

        # Criar tabela de diagnósticos
        inst_cadastro.execute(''' 
            CREATE TABLE diagnosticos (
                id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY NOT NULL,
                placa VARCHAR2(8) NOT NULL,
                descricao_problema VARCHAR2(255) NOT NULL,
                causa_identificada VARCHAR2(255) NOT NULL,
                data_diagnostico DATE NOT NULL,
                tipo_servico VARCHAR2(50) NOT NULL,
                FOREIGN KEY (placa) REFERENCES veiculos(placa)
            )
        ''')

        # Criar tabela de histórico de serviços
        inst_cadastro.execute(''' 
            CREATE TABLE historico_servicos (
            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY NOT NULL,
            placa VARCHAR2(8) NOT NULL,
            descricao_servico VARCHAR2(255) NOT NULL,
            causa_identificada VARCHAR2(255) NOT NULL,
            data_revisao DATE NOT NULL,  -- Renomeada aqui
            modelo VARCHAR2(50) NOT NULL,
            FOREIGN KEY (placa) REFERENCES veiculos(placa)
        )
        ''')

        # Criar a tabela de orçamentos
        inst_cadastro.execute(''' 
            CREATE TABLE orcamentos (
                id_orcamento NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY NOT NULL,
                id_diagnostico NUMBER NOT NULL,
                placa VARCHAR2(8) NOT NULL,
                descricao_servico VARCHAR2(255) NOT NULL,
                valor_estimado NUMBER(10, 2) NOT NULL,
                data_orcamento DATE DEFAULT SYSDATE NOT NULL,

                CONSTRAINT fk_diagnostico
                    FOREIGN KEY (id_diagnostico)
                    REFERENCES diagnosticos(id)
                    ON DELETE CASCADE,
                FOREIGN KEY (placa) 
                    REFERENCES veiculos(placa)
            )
        ''')

        conn.commit()  # Confirma as alterações
        print("Tabelas criadas com sucesso!")

    except oracledb.DatabaseError as e:
        print("Erro ao criar tabelas:", str(e))

criar_tabelas()

# Dicionário para armazenar os veículos cadastrados
veiculos = {}

#Lista para armazena histórico de serviços
historico_servicos = []

# Dicionário para armazenar o histórico de diagnósticos
historico_diagnosticos = {}

# Lista de exemplos de manutenção para serem tratadas
notificacoes_manutencao = [
    {"descricao": "Troca de óleo", "data": date(2024, 5, 15), "status": "pendente", "recorrencia_dias": 180, "causa_identificada": "óleo"},
    {"descricao": "Verificação de freios", "data": date(2023, 10, 1), "status": "resolvida", "recorrencia_dias": 365, "causa_identificada": "freio"},
    {"descricao": "Troca de filtro de ar", "data": date(2023, 7, 1), "status": "pendente", "recorrencia_dias": 365, "causa_identificada": "filtro de ar"}
]

# Dicionário com listas com exemplos de possíveis causas para apresentar para o usuário
possiveis_causas = {
    "freio": ["Desgaste nas pastilhas de freio", "Problema no fluido de freio", "Desgaste nos discos de freio"],
    "óleo": ["Baixo nível de óleo", "Vazamento de óleo", "Filtro de óleo entupido"],
    "motor": ["Superaquecimento", "Falta de óleo", "Falhas na ignição", "Problema no sistema de injeção"],
    "filtro de ar": ["Filtro entupido", "Necessidade de substituição", "Perda de eficiência no motor"]
}

"""Função: limpa a tela do terminal, independente do sistema operacional em que está sendo executada
           se o sistema operacional for Windows (indicado por os.name == 'nt')
    - executa o comando cls para outros sistemas operacionais, como UNix ou Linux (clear
"""
def limpar_tela():
    os.system('cls' if os.name == 'nt' else 'clear')


"""Função: exibe um título formatado no terminal, adicionando uma linha de caracteres "=" acima e abaixo do título para destacá-lo.
   - a quantidade de caracteres "=" corresponde ao comprimento do título

- Parâmetros: 
  - título -> str -> O título a ser exibido, deve ser uma string
"""
def exibir_titulo(titulo):
    print(f"\n{'=' * len(titulo)}\n{titulo}\n{'=' * len(titulo)}")


"""Função: verifica se uma placa de veículo está no formato correto, 
   aceita dois formatos comuns de placas: o formato padrão brasileiro "XXX-0000" e o formato Mercosul "XXXOXOO"

- Parâmetros:
  - placa: str -> a placa do veículo que deve ser validade, deve ser string 

- Retornos:
  - bool: Retorna True se a placa estiver no formato válido, caso o contrário, retorna False
"""
def validar_placa(placa):
    placa = placa.replace(" ", "").upper() # remove espaços e coloca em maiúsculo
    if len(placa) == 8 and placa[3] == '-': # verifica formato "XXX-000"
        if all(placa[i].isalpha() for i in range(3)) and all(placa[i].isdigit() for i in range(4, 8)):
            return True
    elif len(placa) == 7: # verifica formato do padrão Mercosul "XXX0X00"
        if all(placa[i].isalpha() for i in range(3)) and placa[3].isdigit() and placa[4].isalpha() and all(placa[i].isdigit() for i in range(5, 7)):
            return True
    return False # retorna False se a placa for inválida


"""Função: permite cadastrar um novo veículo
   - limpa a tela
   - exibe um título
   - solicita o modelo do veículo e a placa do mesmo
   - a placa é validade para assegurar que está no formato correto e que ainda não foi cadastrada, 
   se a placa for válida, o veículo é adicionado ao dicionário de veículos e inserido no banco de 
   dados junto com a localização do IP obtida através da funçãõ get_location()
   - em caso de erro, uma mensagem apropriada é exibida
"""
def cadastrar_veiculo():
    limpar_tela()
    exibir_titulo("----- CADASTRANDO VEÍCULO -----")
    modelo = input("\tModelo: ")
    
    # Obtém a localização do IP
    localizacao = get_location()  # Chama a função para obter a localização

    while True:
        # Solicita o modelo do veículo e a placa
        placa = input("\tPlaca (XXX-0000 ou XXX0X00): ").upper().strip()
        # Valida a placa e se ela já foi cadastrada
        if validar_placa(placa):
            if placa in veiculos:
                print(f"Veículo com placa {placa} já está cadastrado.")
            else:
                veiculos[placa] = modelo  # Armazena o veículo no dicionário

                try:
                    inst_cadastro.execute(''' 
                        INSERT INTO veiculos (placa, modelo, localizacao) 
                        VALUES (:placa, :modelo, :localizacao)
                    ''', {
                        'placa': placa,
                        'modelo': modelo,
                        'localizacao': localizacao
                    })
                    conn.commit()
                    print(f"\nVeículo {modelo} com placa {placa} cadastrado com sucesso!\n\n\tLocalização Detectada: {localizacao}")

                except oracledb.DatabaseError as e:
                    print("ERRO ao inserir o veículo no Banco de Dados: ", e)

                break
        else:
            print("Placa inválida! Tente novamente.")  # Exibe erro se a placa for inválida


"""Procedimento: permite excluir um veículo específico ou todos os veículos do banco de dados
   - limpa a tela
   - exibe um título
   - verifica se há veículos cadastrados e, em seguida, oferece opções ao usuário, ele solicita a confirmação da exclusão
     - se a exclusão for confirmada, ele remove os registros do banco de dados
"""
def excluir_veiculo():
    limpar_tela()
    exibir_titulo("----- EXCLUIR VEÍCULO -----")

    # Verifica se há veículos cadastrados no banco de dados
    inst_exclusao.execute("SELECT COUNT(1) FROM veiculos")
    total_veiculos = inst_exclusao.fetchone()[0]

    if total_veiculos > 0:  # Se houver veículos cadastrados
        print("\nVocê deseja excluir: ")
        print("\n\t1 - Apenas UM veículo")
        print("\t2 - TODOS os veículos")
        escolha = input("Escolha: ")

        match escolha:
            case '1':
                placa = input("Digite a placa do veículo que deseja excluir: ").upper().strip()  # Solicita a placa

                # Verifica se o veículo existe no banco de dados
                inst_exclusao.execute("SELECT COUNT(1) FROM veiculos WHERE placa = :placa", {'placa': placa})
                veiculo_existe = inst_exclusao.fetchone()[0]

                if veiculo_existe:
                    confirmacao = input(f"Tem certeza que deseja excluir o veículo com placa {placa}? ").lower().strip()
                    
                    if confirmacao == 'sim':
                        # Remove veículo e dados relacionados do banco de dados
                        try:
                            inst_exclusao.execute("DELETE FROM historico_servicos WHERE placa = :placa", {'placa': placa})
                            inst_exclusao.execute("DELETE FROM diagnosticos WHERE placa = :placa", {'placa': placa})
                            inst_exclusao.execute("DELETE FROM veiculos WHERE placa = :placa", {'placa': placa})
                            conn.commit()
                            print(f"Veículo com placa {placa} excluído com sucesso!")

                        except oracledb.DatabaseError as e:
                            print("Erro ao excluir o veículo no Banco de Dados: ", e)
                    else:
                        print("Operação cancelada.")
                else:
                    print("Veículo não encontrado.")  # Exibe erro se o veículo não for encontrado

            case '2':
                confirmacao = input("Tem certeza que deseja excluir TODOS os veículos? ").lower().strip()
                if confirmacao == 'sim':
                    try:
                        inst_exclusao.execute("DELETE FROM historico_servicos")
                        inst_exclusao.execute("DELETE FROM diagnosticos")
                        inst_exclusao.execute("DELETE FROM veiculos")
                        conn.commit()
                        print("Todos os veículos e dados relacionados foram excluídos com sucesso!")

                    except oracledb.DatabaseError as e:
                        print("Erro ao excluir todos os veículos no Banco de Dados: ", e)
                else:
                    print("Operação cancelada.")

    else:
        print("Não há veículos cadastrados no banco de dados.")


"""Procedimento: gera relatórios para diferentes categorias de dados presentes no banco de dados, como vículos, diagnóstico e orçamentos
   - o usuário pode selecionar uma categoria e aplicar filtros para visualizar informações específicas
   - lida com a interação do usuário e exibe os resultados de consultas SQL formatadas

- Parâmetros:
  - conn: Connection -> conexão com o banco de dados 
"""                  
def relatorio_final(conn):
    # inicializando o cursor
    inst_consulta = conn.cursor()

    # menu
    while True:
        limpar_tela()
        print("\nEscolha uma categoria para exibir: ")
        print("""\n
        1 - Veículos
        2 - Diagnósticos
        3 - Orçamentos
        4 - Sair
        """)
        opcao_categoria = input("\nEscolha: ")

        match opcao_categoria:
            case '1':
                limpar_tela()
                exibir_titulo("VEÍCULOS")
                print("\n Escolha um filtro para veículos: ")
                print("""\n
                1 - Placa
                2 - Modelo
                3 - Todos os veículos
                4 - Voltar ao Menu Principal
                """)
                opcao_filtro = input("\nEscolha: ")

                if opcao_filtro == '1':
                    limpar_tela()
                    print("\n----- VEÍCULOS CADASTRADOS -----")
                    placa = input("\nDigite a placa que deseja filtrar: ").strip().upper()
                    if not placa:  # Verificação de entrada vazia
                        print("Placa não pode ser vazia.")
                        continue
                    filtro = "SELECT modelo, placa FROM veiculos WHERE placa LIKE :placa"
                    inst_consulta.execute(filtro, placa=f'%{placa}%')
                    veiculos = inst_consulta.fetchall()

                    if veiculos:
                        for modelo, placa in veiculos:
                            print(f"\n\tModelo: {modelo}, Placa: {placa}")
                    else:
                        print("Veículo não encontrado")

                elif opcao_filtro == '2':
                    limpar_tela()
                    exibir_titulo("VEÍCULOS CADASTRADOS")
                    modelo = input("\nDigite o modelo que deseja filtrar: ").strip().lower()
                    if not modelo:  # Verificação de entrada vazia
                        print("Modelo não pode ser vazio.")
                        continue
                    filtro = "SELECT modelo, placa FROM veiculos WHERE LOWER(modelo) LIKE :modelo"
                    inst_consulta.execute(filtro, modelo=f'%{modelo}%')
                    veiculos = inst_consulta.fetchall()

                    
                    if veiculos:
                        for modelo, placa in veiculos:
                            print(f"\n\tModelo: {modelo}, Placa: {placa}")
                    else:
                        print("Nenhum veículo encontrado com o modelo especificado.")

                elif opcao_filtro == '3':
                    limpar_tela()
                    exibir_titulo("VEÍCULOS CADASTRADOS")
                    filtro = "SELECT modelo, placa FROM veiculos"
                    inst_consulta.execute(filtro)
                    veiculos = inst_consulta.fetchall()

                    
                    for modelo, placa in veiculos:
                        print(f"\n\tModelo: {modelo}, Placa: {placa}")

                elif opcao_filtro == '4':
                    break
                else:
                    print("Opção inválida")
                    continue

            case '2':
                limpar_tela()
                try:
                    filtro = "SELECT id, placa, causa_identificada, data_diagnostico FROM diagnosticos"
                    inst_consulta.execute(filtro)
                    diagnosticos = inst_consulta.fetchall()

                    exibir_titulo("----- DIAGNÓSTICOS CADASTRADOS -----")
                    print(f"\n\t{'ID':<10} {'Placa':<12} {'Causa':<30} {'Data do Diagnóstico':<20}")
                    print("-" * 90)

                    for id, placa, causa, data in diagnosticos:
                        data_str = data.strftime('%Y-%m-%d') if isinstance(data, (oracledb.Date, oracledb.DATETIME)) else str(data)
                        print(f"\t{id:<10} {placa:<12} {causa:<30} {data_str:<20}")

                except oracledb.DatabaseError as e:
                    print(f"Erro ao consultar o Banco de dados: {e}")

            case '3':
                limpar_tela()
                exibir_titulo("ORÇAMENTOS CADASTRADOS")
                print()
                listar_orcamentos(conn)

            case '4':
                break

            case _:
                print("Opção Inválida. Tente Novamente")

        # Pergunta se o usuário deseja exibir outra coisa
        continuar = input("\nDeseja exibir outra coisa? ").strip().lower()
        if continuar not in ['s', 'sim']:
            print("Saindo do relatório final.")
            break

    inst_consulta.close()
 

"""Função: exibe os detalhes dos orçamentos fornecidos
   - formata e apresenta as informações de cada orçamento incluindo ID 
   do orçamento, valos estimado, data e placa do veículo, de forma organizada no terminal

- Parâmetros:
  - orcamentos: list -> uma lista de tuplas, onde cada tupla representa um orçamento
  e contém os valores para ID do orçamento, valor estimado, data e placa do veículo
"""
def exibir_orcamentos(orcamentos):
    """Função auxiliar para exibir orçamentos."""
    print("\tID    Valor      Data                      Placa")
    print("-" * 60)
    for row in orcamentos:
        id_orcamento, valor, data, placa = row
        data_str = data.strftime('%Y-%m-%d') if isinstance(data, (oracledb.Date, oracledb.DATETIME)) else str(data)
        print(f"\t{id_orcamento:<6} {valor:<10} {data_str:<25} {placa}")

"""Função: recupera e exibe os orçamentos presentes no banco de dados
   - executa uma consulta SQL para selecionar os orçamentos e utiliza a 
   função exibir_orcamentos para exibir os resultados de forma formatada
"""
def listar_orcamentos(conn):
    try:
        cursor = conn.cursor()
        cursor.execute('SELECT id_orcamento, valor_estimado, data_orcamento, placa FROM orcamentos')
        orcamentos = cursor.fetchall()
        exibir_orcamentos(orcamentos)

    except oracledb.DatabaseError as e:
        print("Erro ao listar os orçamentos:", e)
    finally:
        cursor.close()


"""Função: gerencia o processo de login
   - verifica se o usuário já possui um login e, com base na resposta
   - solicita os dados de login (nome de usuário e senha)
   - se os dados fornecidos forem válidos, o login é realizado com sucesso,
     caso o contrário, mensagens de erro apropriadas são exibidas

- Retornos:
 - nome_usuario: str -> retorna o nome de usuários após o login ser realizado com sucesso
   """
def fazer_login():
    while True:
        opcao_login = input("\nVocê já possui um login? ").strip().lower() # pergunta se o usuário já tem login
        if opcao_login in ['nao', 'não', 'n']:
            while True:
                nome_usuario = input("\nDigite seu nome de usuário: ").strip()
                if nome_usuario:
                    break
                else:
                    print("Você precisa preencher o nome de usuário.") # exibe erro se o nome estiver vazio
            
            while True:
                senha_login = input("\nDigite sua senha: ").strip() 
                if senha_login:
                    break
                else:
                    print("Você precisa preencher a senha.") # exibe erro se a senha estiver vazia
            print("\nLogin realizado com sucesso!")
            return nome_usuario # retorna nome do usuário
        elif opcao_login in ['sim', 's']:
            while True:
                nome_usuario = input("\nDigite seu nome de usuário: ").strip()
                senha = input("\nDigite sua senha: ").strip()
                if nome_usuario and senha:
                    print("\nLogin realizado com sucesso!")
                    return nome_usuario # retorna nome do usuário
                else:
                    print("\nVocê precisa preencher ambos os campos.") # exibe erro se algum campo estiver vazio
        else:
            print("\nOpção inválida. Por favor, escolha 'sim' ou 'não'.") # exibe erro se a opção for inválida


"""Função: realiza o diagnóstico de um problema em um veículo
   - verifica a existência do veículo no banco de dados
   - solicita a descrição do problema e identifica possíveis 
   - causas dependendo do resultado, pode cadastrar o veículo, 
   - solicitar um orçamento e marcar uma revisão, além de salvar 
   as informações no banco de dados

- Parâmetros:
  - conn: Connection -> conexão com o banco de dados

"""        
def diagnosticar_problema(conn):
    limpar_tela()
    exibir_titulo("----- DIAGNÓSTICO DO VEÍCULO -----")
    placa = input("\nDigite a placa do veículo: ").upper().strip()

    cursor = None  # Inicialize o cursor antes do bloco try
    try:
        cursor = conn.cursor()

        # Verificando se existe o veículo no banco de dados
        cursor.execute("SELECT COUNT(1) FROM veiculos WHERE placa = :placa", {'placa': placa})
        resultado = cursor.fetchone()

        # Print para verificar o resultado da consulta
        print(f"\n\tResultado da consulta para a placa {placa}: {resultado[0]}")

        if resultado[0] > 0:
            print(f"\tVeículo encontrado: {placa}")

            # Adiciona ao dicionário com a informação relevante do veículo
            cursor.execute("SELECT modelo FROM veiculos WHERE placa = :placa", {'placa': placa})
            modelo = cursor.fetchone()[0]
            veiculos[placa] = modelo

        else:
            print(f"Veículo com placa {placa} não encontrado")
            if input("Deseja cadastrar o veículo? ").strip().lower() in ['sim', 's']:
                cadastrar_veiculo()
                veiculos[placa] = "Modelo do Veículo"
                print(f"Veículo {placa} cadastrado com sucesso")
            else:
                return

    except oracledb.DatabaseError as e:
        print(f"Erro ao consultar o Banco de Dados: {e}")
        return

    descricao_problema = input("\nDescreva o problema que está acontecendo com o veículo: ").lower()
    causa_identificada = None

    if "luz" in descricao_problema:
        tipo_luz = input("Qual luz está acesa? (Ex: óleo, freio, motor): ").lower().strip()
        if tipo_luz in possiveis_causas:
            exibir_possiveis_causas(tipo_luz)  # Exibe possíveis causas com base no tipo de luz
            causa_identificada = tipo_luz  # Atribui o tipo de luz como causa identificada
        else:
            print("Tipo de luz não identificada. Recomendamos uma verificação.")
    else:
        for palavra_chave in possiveis_causas:
            if palavra_chave in descricao_problema:
                exibir_possiveis_causas(palavra_chave)
                causa_identificada = palavra_chave
                break
        else:
            print("Problema não identificado. Recomendamos uma verificação.")

    if causa_identificada:
        diagnostico = {
            "descricao_problema": descricao_problema,  # Descrição do problema
            "causa_identificada": causa_identificada,   # Causa do problema
            "data_diagnostico": date.today()   # Data do diagnóstico
        }

        if placa not in historico_diagnosticos:
            historico_diagnosticos[placa] = []
        historico_diagnosticos[placa].append(diagnostico)

        # Inicializa tipo_serviço antes da inserção
        tipo_serviço = ''  

        try:
            cursor.execute('''
                INSERT INTO diagnosticos (placa, descricao_problema, causa_identificada, data_diagnostico, tipo_servico)
                VALUES (:placa, :descricao_problema, :causa_identificada, :data_diagnostico, :tipo_servico)          
            ''', {
                'placa': placa,
                'descricao_problema': descricao_problema,
                'causa_identificada': causa_identificada,
                'data_diagnostico': date.today(),
                'tipo_servico': tipo_serviço if tipo_serviço else "Sem serviço"
            })
            conn.commit()

            print(f"\nDiagnóstico salvo no Banco de Dados para o veículo: \n\t {veiculos[placa]} - placa: {placa}")
        except oracledb.DatabaseError as e:
            print("ERRO ao salvar o diagnóstico no Banco de Dados:", e)
            return  # Se ocorrer erro, não continua o processo

        # Solicitar Orçamento
        opcao_orcamento = input("\nDeseja solicitar um pré-orçamento para este diagnóstico? ").strip().lower()

        if opcao_orcamento in ["sim", "s"]:
            solicitar_orcamento_especifico(conn, placa, causa_identificada)
            tipo_serviço = "Orçamento"  # Atualiza o tipo de serviço

        # Marcar Revisão
        opcao_revisao = input("\nDeseja marcar uma revisão? ").strip().lower()

        if opcao_revisao in ["sim", "s"]:
            agendar_revisao(conn, placa, causa_identificada)
            tipo_serviço = tipo_serviço + " e Revisão" if tipo_serviço else "Revisão"

        print(f"\nServiço(s) selecionado(s): {tipo_serviço}")
        
        # Agora também vamos salvar o tipo de serviço após as opções de orçamento e revisão
        try:
            cursor.execute('''
                UPDATE diagnosticos
                SET tipo_servico = :tipo_servico
                WHERE placa = :placa AND data_diagnostico = :data_diagnostico
            ''', {
                'tipo_servico': tipo_serviço,
                'placa': placa,
                'data_diagnostico': date.today()
            })
            conn.commit()
            print("\nTipo de serviço atualizado no diagnóstico.")
        except oracledb.DatabaseError as e:
            print("ERRO ao atualizar o tipo de serviço no Banco de Dados:", e)

    else:
        print("\nDiagnóstico não realizado.")


"""Função: recupera o ID do diagnóstico correspondente a uma placa específica
   - realiza uma consulta no banco de dados para obter o ID do diagnóstico,
     retornando o ID se encontrado, ou None se não encontrado

- Parâmetros:
  - conn: Connection -> conexão com o banco de dados
  - placa: str -> a placa do veículo cujo ID de diagnóstico deve ser obtida

- Retornos:
  - int ou None: O ID do diagnóstico, ou None se o diagnóstico não for encontrado
"""
def obter_id_diagnostico(conn, placa):

    try:
        cursor = conn.cursor()
        cursor.execute(''' 
            SELECT ID 
            FROM diagnosticos 
            WHERE placa = :placa
        ''', {'placa': placa})
        
        id_diagnostico = cursor.fetchone()
        if id_diagnostico is not None:
            return id_diagnostico[0]  # Retorna apenas o ID do diagnóstico
        else:
            print(f"Nenhum diagnóstico encontrado para a placa: {placa}.")
            return None  # Retorna None se não encontrar nada
    except oracledb.DatabaseError as e:
        print("Erro ao obter ID do diagnóstico:", e)
        return None
    finally:
        if 'cursor' in locals():
            cursor.close()


"""Função: gera um orçamento com base na causa identificada do problema do veículo
   - utiliza uam tabela de preços pré-definida para retornar o valor correspondente
     à causa, se a causa não tiver na tabela, retorna um valoro padrão de 0.00
"""
def gerar_orcamento(causa_identificada):

    tabela_precos = {
        "freio": 500.00,
        "óleo": 150.00,
        "motor": 1200.00,
        "filtro de ar": 300.00
    }
    return tabela_precos.get(causa_identificada, 0.00)


"""Função: recupera o ID do diagnóstico correspondente a uma placa específica
   - realiza uma consulta no banco de dados para obter o ID do diagnóstico, 
    retornando o ID se encontrado, ou None se não
   - lida com exceções de banco de dados e garante que o cursor seja fechado
     corretamente

- Parâmetros:
  - placa: str -> placa do veículo cujo ID de diagnóstico deve ser obtida
  - causa_identificada: str -> não é usado na conulta

- Retornos:
  - int ou None: O ID do diagnóstico, ou None se o diaagnóstico não for encontrado

"""
def buscar_id_diagnostico(placa, causa_identificada):

    try:
        cursor = conn.cursor()
        cursor.execute(''' 
            SELECT id_diagnostico 
            FROM diagnosticos 
            WHERE placa = :placa
        ''', {'placa': placa})
        
        id_diagnostico = cursor.fetchone()
        if id_diagnostico:
            return id_diagnostico[0]  # Retorne apenas o ID do diagnóstico
        else:
            print(f"Nenhum diagnóstico encontrado para a placa: {placa}.")
            return None  # Retorna None se não encontrar nada
    except oracledb.DatabaseError as e:
        print("Erro ao obter ID do diagnóstico:", e)
        return None
    finally:
        if 'cursor' in locals():
            cursor.close()


"""Função: solicita um orçamento específico para um veículo com base na placa
           e na causa identificada do problema
        - limpa a tela
        - exibe um título
        - gera o orçamento e, se o orçamento for maior que zero, insere os
          detalhes no banco de dados, em caso de erro é exibida uma mensagem
          apropriada

- Parâmetro:
  - conn: Connection -> conexão com o banco de dados
  - placa: str -> placa do veículo
  - causa_identificada: str -> causa identificada do problema do veículo 
"""
def solicitar_orcamento_especifico(conn, placa, causa_identificada):
    
    limpar_tela()
    exibir_titulo("----- SOLICITAR ORÇAMENTO -----")
    orcamento = gerar_orcamento(causa_identificada)
    
    # Verifica se o orçamento gerado é maior que zero
    if orcamento > 0:
        print(f"\nOrçamento para {causa_identificada.capitalize()}: R$ {orcamento:.2f}")
        
        try:
            # Obtenha o ID do diagnóstico usando a placa e a causa_identificada
            id_diagnostico = obter_id_diagnostico(conn, placa)
            
            # Valida se o ID do diagnóstico foi encontrado
            if id_diagnostico is None:
                print("ERRO: ID do diagnóstico não encontrado.")
                return
            
            # Valida se a placa e a causa estão corretamente preenchidas
            if not placa or not causa_identificada:
                print("ERRO: Um ou mais campos obrigatórios estão vazios.")
                return
            
            # Insira o orçamento no banco de dados
            cursor = conn.cursor()
            cursor.execute(''' 
                INSERT INTO orcamentos (id_diagnostico, descricao_servico, valor_estimado, placa)
                VALUES (:id_diagnostico, :descricao_servico, :valor_estimado, :placa)
            ''', {
                'id_diagnostico': id_diagnostico,
                'descricao_servico': causa_identificada.capitalize(),
                'valor_estimado': orcamento,
                'placa': placa
            })
            conn.commit()
            print("\nOrçamento salvo com sucesso no banco de dados.")
        except oracledb.DatabaseError as e:
            print(f"ERRO ao salvar o orçamento no Banco de Dados: {e}, dados: placa={placa}, id_diagnostico={id_diagnostico}, descricao_servico={causa_identificada.capitalize()}, valor_estimado={orcamento}")
        finally:
            if cursor:
                cursor.close()
    else:
        print("\nNão foi possível gerar um orçamento para o diagnóstico informado.")


"""Função: insere um novo diagnóstico para um veículo específico no banco de dados
         - verifica se o veículo existe
         - valida a conexão com o banco de dados
         - insere o diagnóstico e retorna o ID do diagnóstico inserido

- Parâmetros:
  - conn: Connection -> conexão com o banco de dados
  - placa: str -> placa do veículo
  - causa_identificada: str -> causa identificada do problema

- Retornos:
  - int ou None: O ID do diagnóstico inserido, ou Nonw se o veículo não for
    encontrado, a conexão estiver fechada, ou ocorrer um erro
"""
def inserir_novo_diagnostico(conn, placa, causa_identificada):
    
    # Verifica se o veículo existe no sistema
    if placa not in veiculos:
        print(f"Veículo com placa {placa} não encontrado.")
        return None  # Retorna None se o veículo não estiver cadastrado

    descricao_problema = "Problema não descrito."  # Descrição padrão

    try:
        # Verifica se a conexão está aberta
        if conn is None or not conn.is_open():
            print("A conexão com o banco de dados está fechada. Verifique a conexão.")
            return None

        cursor = conn.cursor()  # Criação do cursor

        # Insere o novo diagnóstico no banco de dados
        cursor.execute(''' 
            INSERT INTO diagnosticos (placa, descricao_problema, causa_identificada, data_diagnostico, tipo_servico)
            VALUES (:placa, :descricao_problema, :causa_identificada, :data_diagnostico, :tipo_servico)          
        ''', {
            'placa': placa,
            'descricao_problema': descricao_problema,
            'causa_identificada': causa_identificada,
            'data_diagnostico': date.today(),
            'tipo_servico': 'Diagnóstico'
        })
        conn.commit()
        print("Novo diagnóstico inserido com sucesso.")

        # Recupera o ID do diagnóstico inserido
        cursor.execute(''' 
            SELECT id 
            FROM diagnosticos 
            WHERE placa = :placa 
            AND causa_identificada = :causa_identificada 
            AND data_diagnostico = :data_diagnostico
            ORDER BY id DESC 
            FETCH FIRST 1 ROWS ONLY
        ''', {
            'placa': placa,
            'causa_identificada': causa_identificada,
            'data_diagnostico': date.today()
        })
        result = cursor.fetchone()
        return result[0] if result else None  # Retorna o ID do novo diagnóstico

    except oracledb.DatabaseError as e:
        print("ERRO ao inserir novo diagnóstico no Banco de Dados:", e)
        return None
    finally:
        if 'cursor' in locals():
            cursor.close()  # Fecha o cursor para liberar recursos


"""Função: solicita um orçamento para um veículo específico
          - limpa a tela
          - exibe o título
          - verifica a existência do veículo e causa identificada
          - realiza diagnósticos se necessário
          - insere o orçamento no banco de dados
"""
def solicitar_orcamento(conn):
    limpar_tela()
    exibir_titulo("----- SOLICITAR ORÇAMENTO -----")
    placa = input("\nDigite a placa do veículo: ").upper().strip()

    try:
        cursor = conn.cursor()
        cursor.execute(''' 
            SELECT placa, modelo 
            FROM veiculos 
            WHERE placa = :placa
        ''', {'placa': placa})
        veiculo = cursor.fetchone()

        if veiculo is None:
            print(f"Veículo com placa {placa} não encontrado no banco de dados.")
            return
        
        print(f"\n\t- Modelo do veículo: {veiculo[1]}")

        # Obter causa identificada
        causa_identificada = obter_causa_identificada(conn, placa)

        if not causa_identificada:
            print("Nenhuma causa identificada encontrada para essa placa.")
            realizar_diagnostico = input("Deseja fazer um diagnóstico para esta placa? ").strip().lower()
            if realizar_diagnostico in ['s', 'sim']:
                id_diagnostico = diagnosticar_problema()  # Passar a conexão correta aqui
                print(f"ID do Diagnóstico: {id_diagnostico}")
                if id_diagnostico is None:
                    print("Não foi possível criar o diagnóstico.")
                    return
            else:
                return
        else:
            id_diagnostico = obter_id_diagnostico(conn, placa)  # Obter ID de diagnóstico

        print(f"ID do Diagnóstico obtido pela consulta: {id_diagnostico}")
        if id_diagnostico is not None:
            valor_estimado = gerar_orcamento(causa_identificada)
            descricao_servico = f"Serviço de manutenção para {causa_identificada}"
            try:
                cursor.execute(''' 
                    INSERT INTO orcamentos (id_diagnostico, descricao_servico, valor_estimado, data_orcamento, placa)
                    VALUES (:id_diagnostico, :descricao_servico, :valor_estimado, :data_orcamento, :placa)
                ''', {
                    'id_diagnostico': id_diagnostico,
                    'descricao_servico': descricao_servico,
                    'valor_estimado': valor_estimado,
                    'data_orcamento': date.today(),
                    'placa': placa
                })
                conn.commit()
                print(f"\nOrçamento para {causa_identificada} salvo no banco de dados.")
            except oracledb.DatabaseError as e:
                print("ERRO ao salvar o orçamento no Banco de Dados:", e)
        else:
            print("Não foi possível criar o diagnóstico e o orçamento devido à ausência de um ID válido de diagnóstico.")

    except oracledb.DatabaseError as e:
        print("ERRO ao consultar o banco de dados:", e)
    
    finally:
        if 'cursor' in locals():
            cursor.close()


"""Função: recupera  acausa identificada de uma problema para um veículo específico com base na placa
         - realiza uma consulta no banco de dados para obter a causa identificada do diagnóstico mais 
           recente associado à placa fornecida

- Parâmetros:
  - conn: Connection -> conexão com o banco de dados
  - placa: str -> placa do veículo cuja causa identificada deve ser obtida

- Retornos:
  - str ou None: a causa identificada do problema, ou None se nenhum diagnóstico for encontrado
"""
def obter_causa_identificada(conn, placa):
    try:
        cursor = conn.cursor()
        cursor.execute(''' 
            SELECT causa_identificada 
            FROM diagnosticos 
            WHERE placa = :placa
        ''', {'placa': placa})
        resultado = cursor.fetchone()

        # Se houver um resultado, retorna a causa identificada
        if resultado:
            return resultado[0]  # Retorna a causa identificada
        else:
            return None  # Retorna None se não encontrar nada
    except oracledb.DatabaseError as e:
        print("ERRO ao consultar a causa identificada:", e)
        return None  # Retorna None em caso de erro
    finally:
        if cursor:
            cursor.close()  # Fecha o cursor para evitar vazamentos de memória


"""Função: permite agendar uma revisão para um veículo
          - verifica a existência do veículo e, se necessário, cadastra o veículo
          - busca ou solicita a causa identificada do problema e insere a data de 
            revisão no banco de dados se a data fornecida for válida e no futuro

- Parâmetros:
  - conn: Connection -> conexão com o banco de dados
  - placa: str | opcional -> placa do veículo, se não for fornecida, será solicitada ao usuário
  - causa_identificada: str | opcional -> causa identificada do problema, se não for fornecida, 
    será buscada no banco de dados
"""
def agendar_revisao(conn, placa=None, causa_identificada=None):
    limpar_tela()
    exibir_titulo("----- AGENDAR REVISÃO -----")

    cursor = conn.cursor()
    try:
        # Solicita a placa se não foi passada como parâmetro
        if not placa:
            placa = input("\nDigite a placa do veículo: ").upper().strip()
        
        # Verifica se a placa existe no banco de dados
        cursor.execute("SELECT modelo FROM veiculos WHERE placa = :placa", {'placa': placa})
        resultado = cursor.fetchone()

        if resultado is None:
            print(f"Veículo com placa {placa} não encontrado.")
            if input("Deseja cadastrar o veículo? ").strip().lower() in ['sim', 's']:
                cadastrar_veiculo(conn, placa)
            else:
                return
        else:
            modelo = resultado[0]

        # Verifica se a causa identificada já foi fornecida ou busca o último diagnóstico
        if not causa_identificada:
            cursor.execute("SELECT causa_identificada FROM diagnosticos WHERE placa = :placa ORDER BY data_diagnostico DESC", {'placa': placa})
            resultado_diagnostico = cursor.fetchone()
            if resultado_diagnostico:
                causa_identificada = resultado_diagnostico[0]
            else:
                print("Nenhum diagnóstico encontrado para este veículo. Por favor, realize um diagnóstico primeiro.")
                return

        # Loop para agendar a revisão com uma data futura
        while True:
            try:
                data_revisao = input("\nDigite a data da revisão (DD/MM/AAAA): ")
                dia, mes, ano = map(int, data_revisao.split('/'))
                data_revisao_obj = date(ano, mes, dia)
                
                # Verifica se a data é no futuro
                if data_revisao_obj >= date.today():
                    # Realiza a inserção no banco de dados
                    cursor.execute(
                        "INSERT INTO historico_servicos (placa, modelo, descricao_servico, data_revisao, causa_identificada) "
                        "VALUES (:placa, :modelo, :descricao_servico, :data_revisao, :causa_identificada)",
                        {
                            'placa': placa,
                            'modelo': modelo,
                            'descricao_servico': 'Revisão',
                            'data_revisao': data_revisao_obj,
                            'causa_identificada': causa_identificada
                        }
                    )
                    conn.commit()
                    print(f"\n\tRevisão agendada para {modelo} (placa {placa}) em {data_revisao_obj.strftime('%d/%m/%Y')}.")
                    break
                else:
                    print("A data deve ser no futuro.")
            except ValueError:
                print("Data inválida. Por favor, use o formato DD/MM/AAAA.")
    except oracledb.DatabaseError as e:
        error, = e.args
        print("Erro ao agendar revisão no Banco de Dados:", error.message)
    finally:
        cursor.close()


"""Função: insere um novo serviço no histórico de serviços do banco de dados
          - valida a conexão com o banco de dados
          - formata a data corretamente e insere as informações fornecidas
          - se a conexão não estiver ativa ou se ocorrer um erro durante a
            inserção, mensagens apropriada são exibidas

- Parâmetros:
  - placa: src -> placa do veículo
  - descricao_servico: str -> descricao do serviço realizado
  - causa_identificada: str -> causa identificada do problema
  - data: datetime -> data do serviço, deve ser um objeto datetime
  - modelo: str -> modelo do veículo
"""    
def inserir_servico(placa, descricao_servico, causa_identificada, data, modelo):
    try:
        # Verifica se a conexão com o banco de dados está ativa
        if conn is None or conn.closed:
            print("A conexão com o banco de dados está fechada. Verifique a conexão.")
            return

        # Aqui, data já deve ser um objeto datetime
        data_formatada = data.strftime('%Y-%m-%d')  # Formato YYYY-MM-DD

        # Executa a inserção no banco de dados
        inst_cadastro.execute('''
            INSERT INTO historico_servicos (placa, descricao_servico, causa_identificada, data, modelo)
            VALUES (:placa, :descricao_servico, :causa_identificada, TO_DATE(:data, 'YYYY-MM-DD'), :modelo)
        ''', {
            'placa': placa,
            'descricao_servico': descricao_servico,
            'causa_identificada': causa_identificada,
            'data': data_formatada,
            'modelo': modelo
        })

        # Confirma a transação
        conn.commit()
        print("\nServiço inserido com sucesso.")
    
    except oracledb.DatabaseError as e:
        # Exibe detalhes do erro
        error, = e.args
        print("Erro ao inserir o serviço no Banco de Dados:", error.message)


"""Função: exibe o histórico de serviços de veículos no banco de dados
          - permite ao usuário filtrar os resultados por placa ou exibir
            todos os históricos
          - lida com exceções de banco de dados e garante que o cursor 
            seja fechado corretamente

- Parâmetros: 
  - conn: Connection -> conexão com o banco de dados
"""
def mostrar_historico_servicos(conn):
    limpar_tela()
    exibir_titulo("----- HISTÓRICO DE SERVIÇOS -----")
    
    cursor = None
    try:
        if conn is None:
            print("A conexão com o banco de dados não está estabelecida. Verifique a conexão.")
            return

        cursor = conn.cursor()

        # Exibir opções de filtro
        print("\nFiltrar por:")
        print("\n\t1 - Placa")
        print("\t2 - Todos os históricos")
        opcao = input("\nEscolha: ").strip()

        if opcao == '1':
            limpar_tela()
            exibir_titulo("HISTÓRICO DE SERVIÇOS")
            placa = input("\nDigite a placa do veículo: ").strip().upper()
            print(f"\nConsultando histórico para a placa: {placa}")
            query = 'SELECT placa, descricao_servico, causa_identificada, data_revisao, modelo FROM historico_servicos WHERE placa = :placa ORDER BY data_revisao DESC'
            cursor.execute(query, {'placa': placa})
        elif opcao == '2':
            limpar_tela()
            exibir_titulo("HISTÓRICO DE SERVIÇOS")
            print("\nConsultando todos os históricos..")
            query = 'SELECT placa, descricao_servico, causa_identificada, data_revisao, modelo FROM historico_servicos ORDER BY data_revisao DESC'
            cursor.execute(query)
        else:
            print("Opção inválida. Por favor, escolha 1 ou 2.")
            return

        historico_servicos = cursor.fetchall()
        
        print(f"\nServiços encontrados: {len(historico_servicos)}")
        # print("Dados obtidos:", historico_servicos)  # Exibe o conteúdo da consulta

        if historico_servicos:
            print("\n\tPlaca     | Descrição      | Causa             | Data        | Modelo")
            print("-" * 80)

            for servico in historico_servicos:
                placa, descricao_servico, causa_identificada, data_revisao, modelo = servico
                data_formatada = data_revisao.strftime('%Y-%m-%d')  # Corrigido para data_revisao
                print(f"\t{placa:<10} | {descricao_servico:<15} | {causa_identificada:<15} | {data_formatada:<12} | {modelo}")
        else:
            print("\nNenhum serviço foi agendado até o momento.")
    
    except oracledb.DatabaseError as e:
        error, = e.args
        print("Erro ao consultar o histórico de serviços no Banco de Dados:", error.message)

    finally:
        if cursor is not None:
            cursor.close()


"""Função: exibe as notificações de manutenção pendetens e realizadas para veículos
          - permite ao usuário marcar a data para manutenções pendentes, verificando
            e validando a placa do veeículo, e agenda a revisão se a placa for válida
            e a causa identificada estiver definida

- Parâmetros: 
  - conn: Connection -> conexão com o banco de dados        
"""
def mostrar_notificacoes_manutencao(conn):
    limpar_tela()
    exibir_titulo("----- NOTIFICAÇÕES DE MANUTENÇÃO -----")

    # Exibir notificações
    for idx, notificacao in enumerate(notificacoes_manutencao, 1):
        descricao = notificacao["descricao"]
        data = notificacao["data"]
        status = notificacao["status"]

        if status == "pendente":
            print(f"{idx}. ⏳ {descricao}: pendente")
        else:
            print(f"{idx}. ✅ {descricao}: realizada em {data.strftime('%d/%m/%Y')}")

    opcao = input("\nDeseja marcar data para manutenções pendentes? ").strip().lower()
    
    if opcao in ["sim", "s"]:
        try:
            manutencao_idx = int(input("Escolha o número da manutenção para agendar a data: ")) - 1
            
            if 0 <= manutencao_idx < len(notificacoes_manutencao):
                manutencao = notificacoes_manutencao[manutencao_idx]
                
                if manutencao["status"] == "pendente":
                    causa_identificada = manutencao.get("causa_identificada")
                    
                    if not causa_identificada:
                        print("Causa do problema não está definida para esta manutenção.")
                        return

                    placa = input("Digite a placa do veículo para esta manutenção: ").upper().strip()
                    if not validar_placa(placa):  # Verifica se a placa é válida
                        if input("Veículo com placa não encontrado. Deseja cadastrar?: ").lower() in ['sim', 's']:
                            cadastrar_veiculo()  # Chama a função de cadastro de veículo
                            # Verifica novamente se a placa está registrada
                            if not validar_placa(placa):
                                print(f"Veículo com placa {placa} ainda não encontrado após cadastro.")
                                return

                    # Agora vamos agendar a revisão passando a conexão
                    agendar_revisao(conn, placa, causa_identificada)  # Certifique-se de que a função aceita a conexão
                    manutencao["status"] = "resolvida"  # Atualiza o status da manutenção
                    print(f"\tA manutenção '{manutencao['descricao']}' foi agendada com sucesso!")
                else:
                    print("Essa manutenção já foi resolvida.")
            else:
                print("Manutenção inválida. Tente novamente.")
        except ValueError:
            print("Entrada inválida. Por favor, insira um número válido.")


"""Função: exibe as possíveis causas de um determinado problema do veículo
          - recebe o tipo do problema como parâmetro, busca as causas possíveis
            associadas ao tipo do problema no dicionário possiveis_causas, e as
            exibe na tela
- Parâmetros:
  - tipo_problema: str -> O tipo do problema para o qual se deseja exibir as causas possíveis
"""
def exibir_possiveis_causas(tipo_problema):
    print(f"\nCausas possíveis para {tipo_problema}:")
    for causa in possiveis_causas[tipo_problema]:
        print(f"- {causa}")


"""Função: permite ao usuário atualizar informações de um veículo existente,
           especificamente a placa ou modelo do veículo
          - exibe um menu de opções, permite ao usuário escolher a informação
            que deseja atualizar, e pergunta se o usuário deseja fazer outra 
            alteração após cada atualização
"""
def atualizar_veiculo():
    limpar_tela()
    exibir_titulo(" ATUALIZANDO VEÍCULO ")

    while True:
        print("\nEscolha o que deseja alterar:")
        print("""
        1 - Placa
        2 - Modelo
        3 - Voltar
        """)

        opcao_veic = input("Escolha: ")

        if opcao_veic == '1':
            limpar_tela()
            atualizar_placa(conn)
        elif opcao_veic == '2':
            limpar_tela()
            atualizar_modelo()
        elif opcao_veic == '3':
            break
        else:
            print("Opção Inválida. Tente Novamente.")

        # Perguntar ao usuário se ele quer fazer outra alteração
        continuar = input("\nDeseja fazer outra alteração? ").strip().lower()
        if continuar not in ['s', 'sim']:
            break


"""Função: atualiza a placa de um veículo no banco de dados
          - valida os formatos da placa antiga e da nova, 
          - verifica se a nova placa já existe, 
          - adiciona a nova placa na tabela de veículos, 
          - atualiza os registros filhos que referenciam a placa antiga
          - remove a placa antiga da tabela
          - lida com possíveis erros de banco de dados
"""
def atualizar_placa(conn):
    exibir_titulo("----- ATUALIZANDO PLACA -----")
    placa_antiga = input("\n\tPlaca do veículo que deseja alterar (XXX-0000 ou XXX0X00): ").upper().strip()

    if not validar_placa(placa_antiga):
        print("Formato da placa inválido.")
        return

    nova_placa = input("\tNova Placa (XXX-0000 ou XXX0X00): ").upper().strip()
    if not validar_placa(nova_placa):
        print("Formato da nova placa inválido.")
        return

    cursor = None
    try:
        cursor = conn.cursor()

        # Verifica se a nova placa já existe na tabela veiculos
        cursor.execute('SELECT COUNT(*) FROM veiculos WHERE placa = :nova_placa', {'nova_placa': nova_placa})
        if cursor.fetchone()[0] > 0:
            print("A nova placa já existe no banco de dados.")
            return

        # Adicionar a nova placa na tabela veiculos com todos os campos obrigatórios
        cursor.execute('''
            INSERT INTO veiculos (placa, modelo, localizacao)
            SELECT :nova_placa, modelo, localizacao
            FROM veiculos
            WHERE placa = :placa_antiga
        ''', {'nova_placa': nova_placa, 'placa_antiga': placa_antiga})

        # Atualizar registros filhos que referenciam a placa antiga
        cursor.execute('''
            UPDATE orcamentos SET placa = :nova_placa WHERE placa = :placa_antiga
        ''', {'nova_placa': nova_placa, 'placa_antiga': placa_antiga})

        cursor.execute('''
            UPDATE historico_servicos SET placa = :nova_placa WHERE placa = :placa_antiga
        ''', {'nova_placa': nova_placa, 'placa_antiga': placa_antiga})

        conn.commit()

        # Remover a placa antiga da tabela veiculos
        cursor.execute('''
            DELETE FROM veiculos WHERE placa = :placa_antiga
        ''', {'placa_antiga': placa_antiga})

        conn.commit()
        print(f"Placa atualizada de {placa_antiga} para {nova_placa} com sucesso!")

    except oracledb.DatabaseError as e:
        error, = e.args
        print(f"ERRO ao atualizar a placa no Banco de Dados: {error.message}")

    finally:
        if cursor:
            cursor.close()


"""Função: atualiza o modelo de um veículo no banco de dados
          - valida o formato da placa fornecida
          - solicita o novo modelo
          - atualiza o banco de dados
          - em caso de erro, exibe ums mensagem apropriada
"""
def atualizar_modelo():

    exibir_titulo("----- ATUALIZANDO MODELO -----")
    placa = input("\tPlaca do veículo para atualizar modelo: ").upper().strip()
    if not validar_placa(placa):
        print("Formato da placa inválido.")
        return

    if validar_placa(placa):
        novo_modelo = input("\tNovo modelo: ")
        try:
            inst_cadastro.execute('''UPDATE veiculos SET modelo = :modelo WHERE placa = :placa''', {
                'modelo': novo_modelo,
                'placa': placa
            })
            conn.commit()
            print(f"Modelo do veículo com placa {placa} atualizado para {novo_modelo} com sucesso!")
        except oracledb.DatabaseError as e:
            print("ERRO ao atualizar o modelo no Banco de Dados:", e)
    else:
        print("Veículo não encontrado no banco de dados.")


from datetime import datetime


"""Função: exporta dados fornecidos para um arquivo JSON
          - o nome do arquivo inclui data atual no formato YYYY-MM-DD_dados.json
          - durante a exportação, a função converte objetos datetime para strings formatadaas

- Parâmetros: 
  - dados: dict -> dicionário contendo os dados a serem exportados
"""
def exportar_dados_para_json(dados):
    data_atual = datetime.now().strftime("%Y-%m-%d")
    nome_arquivo = f"{data_atual}_dados.json"

    # Converte objetos datetime em strings
    def converter(obj):
        if isinstance(obj, datetime):
            return obj.strftime("%Y-%m-%d")
        raise TypeError("Tipo não serializável")

    try:
        with open(nome_arquivo, 'w', encoding='utf-8') as arquivo_json:
            json.dump(dados, arquivo_json, default=converter, ensure_ascii=False, indent=4)
        print(f"Dados exportados com sucesso para {nome_arquivo}")
    except Exception as e:
        print(f"Erro ao exportar dados para JSON: {e}")


"""Função: obtém os dados dos veículos armazenados no banco de dados e os
           retorna em formato de lista de dicionários
          - cada dicionário contém a placa, modelo e localização de um veículo

- Parâmetros:
  - conn: Connection -> conexão com o banco de dados

- Retornos:
  - list: lista de dicionários, onde cada dicionário contém os dados de um veículo
        (placa, modelo, localização)  , se ocorrer um erro, retorna uma lista vazia         
"""
def obter_dados_veiculos(conn):
    try:
        cursor = conn.cursor()
        cursor.execute('SELECT placa, modelo, localizacao FROM veiculos')
        veiculos = cursor.fetchall()
        return [{"placa": v[0], "modelo": v[1], "localizacao": v[2]} for v in veiculos]
    except oracledb.DatabaseError as e:
        print(f"Erro ao obter dados dos veículos: {e}")
        return []
    finally:
        cursor.close()


"""Função: obtém os dados dos diagnósticos armazenados no banco de dados 
           e os retorna em formato de lista de dicionários
          - Cada dicionário contém o ID, placa, descrição do problema, 
            causa identificada, data do diagnóstico e tipo de serviço 
            do diagnóstico

- Parâmetros: 
  - conn: Connection -> conexão com o banco de dados

- Retornos:
  - list: uma lista de dicionários, onde cada dicionário contém os dados 
          de um diagnóstico (id, placa, descricao_problema, causa_identificada, 
          data_diagnostico, tipo_servico) se ocorrer um erro, retorna uma lista vazia 

"""
def obter_dados_diagnosticos(conn):
    try:
        cursor = conn.cursor()
        cursor.execute('SELECT id, placa, descricao_problema, causa_identificada, data_diagnostico, tipo_servico FROM diagnosticos')
        diagnosticos = cursor.fetchall()
        return [{"id": d[0], "placa": d[1], "descricao_problema": d[2], "causa_identificada": d[3], "data_diagnostico": d[4], "tipo_servico": d[5]} for d in diagnosticos]
    except oracledb.DatabaseError as e:
        print(f"Erro ao obter dados dos diagnósticos: {e}")
        return []
    finally:
        cursor.close()


"""Função: obtém os dados do histórico de serviços armazenados no banco de dados
           e os retorna em formato de lista de dicionários
          - cada dicionário contém a placa, descrição do serviço, causa identificada, 
            data da revisão e modelo do veículo

- Parâmetros:
  - conn: Connection -> conexão com o banco de dados

- Retornos: 
  - list: lista de dicionários, onde cada dicionário contém os dados de um histórico de serviço
          (placa, descricao_servico, causa_identificada, data_revisao, modelo), 
          se ocorrer um erro, retorna uma lista vazia
"""
def obter_dados_historico_servicos(conn):
    try:
        cursor = conn.cursor()
        cursor.execute('SELECT placa, descricao_servico, causa_identificada, data_revisao, modelo FROM historico_servicos')
        historico_servicos = cursor.fetchall()
        return [{"placa": h[0], "descricao_servico": h[1], "causa_identificada": h[2], "data_revisao": h[3], "modelo": h[4]} for h in historico_servicos]
    except oracledb.DatabaseError as e:
        print(f"Erro ao obter dados do histórico de serviços: {e}")
        return []
    finally:
        cursor.close()


"""Função: obtém os dados dos orçamentos armazenados no banco de dados e os retorna em formato de lista de dicionários
          - cada diagnóstico contém o ID do orçamento, ID do diagnóstico, placa, descriçãõ do serviço, valor estimado
            e data do orçamento

- Parâmetros:
  - conn: Connection -> conexão com o banco de dados

- Retornos:
  - list: lista de dicionários, onde cada dicionário contém os dados de um orçamento
          (id_orcamento, id_diagnostico, placa, descricao_servico, valor_estimado, data_orcamento)
          se ocorrer um erro, retorna uma lista vazia
"""
def obter_dados_orcamentos(conn):
    try:
        cursor = conn.cursor()
        cursor.execute('SELECT id_orcamento, id_diagnostico, placa, descricao_servico, valor_estimado, data_orcamento FROM orcamentos')
        orcamentos = cursor.fetchall()
        return [{"id_orcamento": o[0], "id_diagnostico": o[1], "placa": o[2], "descricao_servico": o[3], "valor_estimado": o[4], "data_orcamento": o[5]} for o in orcamentos]
    except oracledb.DatabaseError as e:
        print(f"Erro ao obter dados dos orçamentos: {e}")
        return []
    finally:
        cursor.close()


"""Função: exibe o menu principal do sistema ChatCar, permitindo ao usuário realizar
          várias operações relacionadas a diagnósticos automotivos, como:
            - cadastrar um veículo, 
            - excluir um veículo, 
            - alterar dados do veículo,
            - exibir relatórios,
            - diagnosticar problemas,
            - agendar revisões,
            - mostrar histórico de serviços,
            - ver notificações de manutenção,
            - solicitar orçamento
          - gerencia o fluxo de navegação do usuário executando a função apropriada
            com base na opção selecionada
"""
def menu():
    limpar_tela()
    exibir_titulo(" ChatCar - seu assistente de diagnósticos automotivos!")
    nome_usuario = fazer_login()
    while True:
        limpar_tela()
        exibir_titulo(f"Bem-vindo(a), {nome_usuario}!")
        print("1. Cadastrar veículo")
        print("2. Excluir veículo")
        print("3. Alterar Dados Veículo")
        print("4. Exibições")
        print("5. Diagnosticar problema")
        print("6. Agendar revisão")
        print("7. Mostrar histórico de serviços")
        print("8. Ver notificações de manutenção")
        print("9. Solicitar Orçamento")
        print("10. Exportar dados para JSON")
        print("11. Sair")
        opcao = input("\nEscolha uma opção: ")

        match opcao:
            
            case '1':
                cadastrar_veiculo() # cadastrar um veículo
            
            case '2':
                excluir_veiculo() # exclui um veículo
            
            case '3':
                atualizar_veiculo()
            
            case '4':
                relatorio_final(conn) # exibe os veículos cadastrados
            
            case '5':
                diagnosticar_problema(conn) # diagnostica um problema no veículo
            
            case '6':
                agendar_revisao(conn) # agenda uma revisão para o veículo
            
            case '7':
                mostrar_historico_servicos(conn) # exibe o histórico de serviços
            
            case '8':
                mostrar_notificacoes_manutencao(conn) # exibe as notificações de manutenção
            
            case '9':
                solicitar_orcamento(conn) # solicita um orçamento para o veículo

            case '10':
                opcao_exportar = input("\nDeseja exportar os dados para JSON? ").strip().lower()
                if opcao_exportar in ['s', 'sim']:    
                    veiculos = obter_dados_veiculos(conn)
                    diagnosticos = obter_dados_diagnosticos(conn)
                    historico_servicos = obter_dados_historico_servicos(conn)
                    orcamentos = obter_dados_orcamentos(conn)
                    dados = {
                        "veiculos": veiculos,
                        "diagnosticos": diagnosticos,
                        "historico_servicos": historico_servicos,
                        "orcamentos": orcamentos
                    }
                    exportar_dados_para_json(dados)

            case '11':
                print("\nSaindo...") # exibe uma mensagem de sáida
                break # encerra o loop e o programa
            
            case _:
                # informa o usuário sobre uma opção inválida
                print("Opção inválida.")
        input("\nPressione Enter para continuar...")

# PROGRAMA PRINCIPAL
menu()
